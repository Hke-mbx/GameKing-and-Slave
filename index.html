<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>王与奴 — 在线</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
<style>
  body{font-family:"Microsoft YaHei","Cinzel",serif;background:linear-gradient(180deg,#1b0710,#241018);color:#f0e6d2;margin:0;padding:18px;display:flex;justify-content:center;}
  .wrap{width:1150px;max-width:100%;display:grid;grid-template-columns:1fr 360px;gap:18px}
  .panel{background:rgba(0,0,0,0.45);padding:14px;border-radius:10px;border:1px solid rgba(212,175,55,0.06)}
  header{grid-column:1/-1;text-align:center;margin-bottom:6px}
  h1{color:#d4af37;margin:0}
  .row{display:flex;gap:8px;align-items:center}
  button{background:#d4af37;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
  input,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#f0e6d2}
  .hand{display:flex;gap:10px;flex-wrap:wrap}
  .card{width:110px;height:150px;border-radius:10px;background:linear-gradient(180deg,#2b1912,#351f15);border:2px solid rgba(212,175,55,0.08);padding:8px;cursor:pointer;display:flex;flex-direction:column;justify-content:space-between}
  .card.back{background:linear-gradient(180deg,#3d2220,#2a1412); color:transparent}
  #log{height:260px;overflow:auto;background:rgba(0,0,0,0.5);padding:8px;border-radius:6px}
  .small{font-size:13px;color:#e9decf}
  .selected{outline:3px solid rgba(212,175,55,0.22);transform:translateY(-6px)}
</style>
</head>
<body>
<div class="wrap">
  <header class="panel">
    <h1>王与奴 — 在线对战（演示）</h1>
    <div class="small">请确保后端 server.js 已启动并可通过 WebSocket 连接（见 README）。</div>
  </header>

  <main class="panel" id="main">
    <div id="loginUI">
      <div class="row" style="gap:12px">
        <input id="inputName" placeholder="输入昵称"/>
        <button id="btnLogin">进入大厅</button>
      </div>
      <div style="margin-top:12px" class="small">会为你生成 userId（保存在 localStorage），用于重连与识别。</div>
    </div>

    <div id="lobbyUI" style="display:none">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div>
          <select id="openingSelect"><option value="king">国王开局</option><option value="queen">女王开局</option><option value="slave">奴隶开局</option></select>
          <button id="btnCreateRoom">创建房间</button>
        </div>
        <div class="small">已连接：<span id="onlineCount">0</span></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">在线玩家</div>
        <div id="usersList" style="max-height:120px;overflow:auto"></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">房间列表</div>
        <div id="roomsList" style="max-height:220px;overflow:auto"></div>
      </div>

      <div style="margin-top:12px" class="small">房间创建后可分享房间号给对手；两人加入房间后房主可点击「开始对战」。</div>
    </div>

    <div id="roomUI" style="display:none">
      <div class="row" style="justify-content:space-between">
        <div><strong>房间：</strong><span id="roomIdDisplay"></span></div>
        <div><button id="btnLeaveRoom">离开房间</button></div>
      </div>
      <div style="margin-top:8px">
        <div class="small">玩家：</div>
        <div id="roomPlayers"></div>
      </div>
      <div style="margin-top:8px">
        <button id="btnStartMatch" disabled>开始对战（房主）</button>
      </div>
    </div>

    <div id="gameUI" style="display:none">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div><strong>房间：</strong><span id="gameRoomId"></span> • 回合：<span id="gameRound">0</span></div>
        <div>
          <button id="btnForfeit">认输</button>
          <button id="btnExitGame">退出对战</button>
        </div>
      </div>

      <div style="margin-top:8px;display:flex;gap:12px">
        <div style="flex:1">
          <div class="small">对手出牌区</div>
          <div id="opponentPlayed" style="min-height:120px;border-radius:8px;background:rgba(0,0,0,0.06);padding:8px"></div>

          <div style="margin-top:8px" class="small">对手手牌数：<span id="opponentCount">0</span></div>

          <div style="margin-top:8px" id="battleLog" class="small"></div>
        </div>

        <div style="width:380px">
          <div class="small">你的手牌</div>
          <div id="playerHand" class="hand" style="margin-top:8px"></div>
          <div style="margin-top:8px" class="row">
            <button id="btnPlayCard">出牌（确认）</button>
            <button id="btnSkipCard">跳过（弃一）</button>
          </div>
        </div>
      </div>

      <div style="margin-top:12px" id="gameMessages" class="small"></div>
    </div>

  </main>

  <aside class="panel">
    <div class="small">本地战绩（浏览器保存）</div>
    <div id="localRecord" style="margin-top:8px" class="small">胜 0 / 负 0 / 平 0</div>
    <div style="margin-top:12px">
      <div class="small">调试</div>
      <div style="margin-top:8px" class="row"><button id="btnRoomsRefresh">刷新房间</button><button id="btnUsersRefresh">刷新玩家</button></div>
      <div style="margin-top:8px" class="small">服务器地址：<input id="serverURL" style="width:100%" value="" placeholder="可留空使用当前页面的 socket 地址"/></div>
    </div>
    <div style="margin-top:14px" class="small">说明：若你把前端部署到 GitHub Pages，请把后端部署到 Render 并替换上方 server URL（例如 wss://your-app.onrender.com）。</div>
  </aside>
</div>

<!-- socket.io client -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
/* ---------- Config & Storage ---------- */
const LOCAL_USER_KEY = 'wangnu_online_user_v1';
const LOCAL_RECORD_KEY = 'wangnu_online_record_v1';
const defaultServer = ''; // if empty, will use current origin (ws same host)
let serverURL = localStorage.getItem('wangnu_server_url') || defaultServer;

/* ---------- Local record ---------- */
let localRecord = JSON.parse(localStorage.getItem(LOCAL_RECORD_KEY) || '{"wins":0,"losses":0,"draws":0}');
function updateLocalRecordUI(){ document.getElementById('localRecord').textContent = `胜 ${localRecord.wins} / 负 ${localRecord.losses} / 平 ${localRecord.draws}`; }

/* ---------- Socket & user ---------- */
let socket = null;
let user = JSON.parse(localStorage.getItem(LOCAL_USER_KEY) || 'null');

function connectSocket(){
  if(socket && socket.connected) return;
  const url = document.getElementById('serverURL').value.trim() || serverURL;
  const opts = {};
  socket = io(url || undefined, opts);
  socket.on('connect', ()=> {
    console.log('socket connected', socket.id);
    if(user) socket.emit('register', { userId: user.id, name: user.name }, (res)=> {
      if(res && res.ok){ user = { ...user, id: res.user.id, name: res.user.name }; localStorage.setItem(LOCAL_USER_KEY, JSON.stringify(user)); showLobbyUI(); }
    });
  });
  // server broadcasts
  socket.on('users:update', (list)=> renderUsers(list));
  socket.on('rooms:update', (rooms)=> renderRooms(rooms));
  socket.on('room:update', (room)=> onRoomUpdated(room));
  socket.on('room:ready', ({ roomId }) => { if(currentRoomId === roomId) updateRoomReady(true); });
  socket.on('match:started', (data)=> onMatchStarted(data));
  socket.on('match:played', (data)=> onMatchPlayed(data));
  socket.on('match:resolved', (data)=> onMatchResolved(data));
  socket.on('match:finished', (data)=> onMatchFinished(data));
}

document.getElementById('btnLogin').addEventListener('click', ()=> {
  const name = document.getElementById('inputName').value.trim() || ('玩家'+Math.floor(Math.random()*900));
  if(!user) user = { id:null, name };
  else user.name = name;
  localStorage.setItem(LOCAL_USER_KEY, JSON.stringify(user));
  connectSocket();
});

// refresh controls
document.getElementById('btnRoomsRefresh').addEventListener('click', ()=> { if(socket) socket.emit('rooms:list', {}, (res)=> { if(res && res.rooms) renderRooms(res.rooms); })});
document.getElementById('btnUsersRefresh').addEventListener('click', ()=> { if(socket) socket.emit('rooms:list', {}, ()=>{}); });

/* ---------- Lobby UI ---------- */
function showLobbyUI(){
  document.getElementById('loginUI').style.display='none';
  document.getElementById('lobbyUI').style.display='block';
  // request lists
  if(socket) {
    socket.emit('rooms:list', {}, (res)=> { if(res && res.rooms) renderRooms(res.rooms); });
    // update online count by requesting users
    // server pushes 'users:update' periodically as well
  }
}

function renderUsers(list){
  const el = document.getElementById('usersList'); el.innerHTML='';
  const arr = list || [];
  document.getElementById('onlineCount').textContent = arr.filter(u=>u.online).length;
  arr.forEach(u=>{
    const div = document.createElement('div'); div.className='small';
    div.innerHTML = `<strong>${u.name}</strong> (${u.online? '在线':'离线'})`;
    el.appendChild(div);
  });
}

function renderRooms(list){
  const el = document.getElementById('roomsList'); el.innerHTML='';
  (list||[]).forEach(r=>{
    const div = document.createElement('div');
    const players = r.players.map(p=>p.name).join(', ');
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div class="small"><strong>${r.id}</strong> • ${players}</div><div><button data-id="${r.id}" class="joinBtn">加入</button></div></div>`;
    el.appendChild(div);
  });
  Array.from(el.querySelectorAll('.joinBtn')).forEach(b => {
    b.onclick = ()=> {
      const id = b.dataset.id;
      if(!socket) return alert('未连接服务器');
      socket.emit('room:join', { roomId: id, userId: user.id }, (res)=> {
        if(res && res.ok){ openRoomUI(res.room); }
        else alert('加入房间失败：'+(res.error||'未知'));
      });
    };
  });
}

/* ---------- Create room ---------- */
let currentRoomId = null;
document.getElementById('btnCreateRoom').addEventListener('click', ()=> {
  const opening = document.getElementById('openingSelect').value;
  if(!socket) return alert('未连接服务器');
  socket.emit('room:create', { hostId: user.id, opening }, (res)=> {
    if(res && res.ok){ openRoomUI(res.room); } else alert('创建房间失败');
  });
});

function openRoomUI(room){
  currentRoomId = room.id;
  document.getElementById('lobbyUI').style.display='none';
  document.getElementById('roomUI').style.display='block';
  document.getElementById('roomIdDisplay').textContent = room.id;
  document.getElementById('roomPlayers').innerHTML = room.players.map(p=>`<div class="small">${p.name}</div>`).join('');
  // enable start if you're host and players >=2
  const isHost = room.hostId === user.id;
  const startBtn = document.getElementById('btnStartMatch');
  startBtn.disabled = !(isHost && room.players.length>=2);
  startBtn.onclick = ()=> {
    // trigger match:start
    socket.emit('match:start', { roomId: room.id }, (res)=> {
      if(!res || !res.ok) alert('无法开始对战：'+(res && res.error));
    });
  };
  document.getElementById('btnLeaveRoom').onclick = ()=> {
    socket.emit('room:leave', { roomId: room.id, userId: user.id }, (res)=> {
      currentRoomId = null; document.getElementById('roomUI').style.display='none'; document.getElementById('lobbyUI').style.display='block';
    });
  };
}

/* room update listener */
function onRoomUpdated(room){
  if(!room) return;
  if(room.id !== currentRoomId) return;
  document.getElementById('roomPlayers').innerHTML = room.players.map(p=>`<div class="small">${p.name}</div>`).join('');
  const isHost = room.hostId === user.id;
  document.getElementById('btnStartMatch').disabled = !(isHost && room.players.length>=2);
  document.getElementById('roomIdDisplay').textContent = room.id;
}
function updateRoomReady(ready){
  if(ready && currentRoomId){ document.getElementById('btnStartMatch').disabled = false; }
}

/* ---------- Match events from server ---------- */
let localMatch = null;

function onMatchStarted(data){
  // data: { roomId, players, counts }
  const roomId = data.roomId;
  currentRoomId = roomId;
  document.getElementById('roomUI').style.display='none';
  document.getElementById('gameUI').style.display='block';
  document.getElementById('gameRoomId').textContent = roomId;
  document.getElementById('gameRound').textContent = 1;
  // create local match structure: we will display hands counts and wait for server to send hands indirectly (server doesn't send full hand)
  // But server uses room.hands; to simplify, client will request room state by calling rooms:list (or receive match:started then request room data via API) 
  // For MVP we'll rely on server to notify played events and resolved events, and server will manage counts in 'counts' field.
  localMatch = { roomId, round:1, myPlayed:null, oppPlayed:null, selectedCardId:null };
  document.getElementById('battleLog').textContent = '';
  // show counts
  renderHandPlaceholders(data.counts);
}

function renderHandPlaceholders(counts){
  // render player hand as hidden slots until server sends details (server currently doesn't push full hands due to security).
  // For a nicer UX, we will request /api/rooms to get summary (counts only). Real implementation would send hands to each player privately.
  const myCountObj = counts.find(c=>c.pid === user.id) || { count: 0 };
  const opp = counts.find(c=>c.pid !== user.id) || { count: 0 };
  // Render player's hand as clickable placeholders (we will request actual card list via a new event in future).
  const playerHandEl = document.getElementById('playerHand');
  playerHandEl.innerHTML = '';
  for(let i=0;i<myCountObj.count;i++){
    const div = document.createElement('div'); div.className='card back'; div.textContent = '牌';
    // NOTE: we need real hand details; as MVP server did not send per-player hand to other players, we fetch via simple REST /api/rooms then require real implementation to deliver hand privately.
    // To keep MVP playable: We will ask server to emit 'match:hand' privately to each socket on match:start in future iterations.
    playerHandEl.appendChild(div);
  }
  document.getElementById('opponentCount').textContent = opp.count;
}

/* match:played - someone played a card (revealed summary) */
function onMatchPlayed({ roomId, userId, cardSummary }){
  // Show in battle log
  const who = userId === user.id ? '你' : (cardSummary && cardSummary.name ? '对手' : '对手');
  const msg = `${who} 出牌（背面）`;
  appendBattleLog(msg);
}

/* match:resolved - server sends events and updated counts */
function onMatchResolved({ room, events, counts }){
  // show events in UI
  appendBattleLog('回合结算：');
  events.forEach(ev=>{
    if(ev.type==='assassin:draw') appendBattleLog(`刺客抽牌导致阵亡：${ev.killed? ev.killed.name: ''}`);
    else if(ev.type==='assassin:bothdie') appendBattleLog('双方刺客互相作用，均发生抽牌/阵亡');
    else if(ev.type==='butcher:bothdie') appendBattleLog('屠夫出现 — 双方本回合出牌一同阵亡');
    else if(ev.type==='assassin:kill') appendBattleLog(`刺客击杀：${ev.target? ev.target.name : ''}`);
    else if(ev.type==='ultguard:kills_assassin') appendBattleLog('终极守卫击杀了刺客');
    else if(ev.type==='special') appendBattleLog(`特殊事件：由 ${ev.winner} 胜出`);
    else if(ev.type==='normal') appendBattleLog(`普通比较，胜者：${ev.winner}`);
    else if(ev.type==='tie') appendBattleLog('等级相同，双方阵亡');
    else if(ev.type==='queen:died') appendBattleLog(`女王陨落，国王立即上阵`);
  });
  // update counts UI
  const myCountObj = counts.find(c=>c.pid === user.id) || { count:0 };
  const opp = counts.find(c=>c.pid !== user.id) || { count:0 };
  // regenerate placeholders
  const playerHandEl = document.getElementById('playerHand');
  playerHandEl.innerHTML = '';
  for(let i=0;i<myCountObj.count;i++){
    const div = document.createElement('div'); div.className='card back'; div.textContent = '牌';
    playerHandEl.appendChild(div);
  }
  document.getElementById('opponentCount').textContent = opp.count;
}

/* match:finished */
function onMatchFinished({ winner, room }){
  if(winner === user.id) { alert('你获胜！'); localRecord.wins++; localStorage.setItem(LOCAL_RECORD_KEY, JSON.stringify(localRecord)); updateLocalRecordUI(); }
  else { alert('你失败。'); localRecord.losses++; localStorage.setItem(LOCAL_RECORD_KEY, JSON.stringify(localRecord)); updateLocalRecordUI(); }
  // go back to lobby
  document.getElementById('gameUI').style.display='none';
  document.getElementById('lobbyUI').style.display='block';
}

/* ---------- Play card UI (MVP) ---------- 
   NOTE: For privacy & security, server should send each player's hand privately.
   For MVP in this deliverable I implement a simplified flow:
   - After match:start, server SHOULD emit 'match:hand' privately to each socket containing the player's hand (array of cards).
   - But our server implementation currently stores hands in memory and does not yet send them on match:started.
   To make this work now: we will call a REST API /api/rooms and/or ask server to send private hand via socket.
   Let's use a private event 'match:hand:request' which server can respond with 'match:hand' to the socket that requested.
*/

/* Request personal hand from server */
function requestMyHand(){
  if(!socket || !currentRoomId) return;
  socket.emit('match:hand:request', { roomId: currentRoomId, userId: user.id }, (res)=> {
    if(res && res.ok && res.hand){
      populateHandUI(res.hand);
    } else {
      // fallback: display placeholder (already done)
      console.warn('无法获取手牌（服务器未返回手牌），使用占位显示');
    }
  });
}

/* Populate player's hand with real cards (callable when server supports it) */
function populateHandUI(hand){
  const el = document.getElementById('playerHand'); el.innerHTML='';
  hand.forEach(card=>{
    const d = document.createElement('div'); d.className='card';
    d.innerHTML = `<div style="font-weight:800;color:#d4af37">${card.name}</div><div class="small">${card.tag}</div><div style="text-align:right">Lv.${card.lvl}</div>`;
    d.onclick = ()=> {
      // select highlight
      Array.from(el.children).forEach(ch=>ch.classList.remove('selected'));
      d.classList.add('selected');
      selectedCardId = card._id;
    };
    el.appendChild(d);
  });
}

/* Playing card: send match:play to server with cardId */
let selectedCardId = null;
document.getElementById('btnPlayCard').addEventListener('click', ()=> {
  if(!socket || !currentRoomId) return alert('未在房间中');
  // if we have selectedCardId (from populateHandUI), use it. Else ask server to pick first available card automatically.
  if(!selectedCardId){
    // fallback: try to pick the first placeholder by requesting a hand first
    return requestMyHand(), alert('未选择具体卡牌，已请求服务器下发手牌（如果后端支持）');
  }
  socket.emit('match:play', { roomId: currentRoomId, userId: user.id, cardId: selectedCardId }, (res)=> {
    if(!res || !res.ok) alert('出牌失败: '+(res && res.error));
    else { appendBattleLog('你已出牌（等待对方）'); selectedCardId = null; }
  });
});

document.getElementById('btnSkipCard').addEventListener('click', ()=> {
  // skipping not built-in server side; as a workaround we can ask server to play a 'skip' action (not implemented).
  alert('跳过（弃一张）目前在在线模式下由客户端本地实现需服务器支持，此处请通过出一张不想要的牌模拟。');
});

/* utility logs */
function appendBattleLog(s){
  const el = document.getElementById('battleLog');
  el.innerHTML = `<div>&gt; ${s}</div>` + el.innerHTML;
}

/* UI helpers on page load */
updateLocalRecordUI();
document.getElementById('serverURL').value = serverURL;
document.getElementById('usersList').innerHTML = '';
document.getElementById('roomsList').innerHTML = '';

// connect immediately if we have saved user
if(user){
  // try connect
  connectSocket();
  // auto register when socket connects (handled in connect)
  document.getElementById('inputName').value = user.name || '';
  // show lobby if already connected in connect callback
}

</script>
</body>
</html>
