<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ç‹ä¸å¥´ â€” å¯ç©ç‰ˆï¼ˆå•é¡µï¼‰</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-1:#12040a; --panel: #17121a; --accent:#d4af37; --muted:#e9decf;
    --glass: rgba(255,255,255,0.04);
  }
  *{box-sizing:border-box}
  body{font-family:"Microsoft YaHei", "Cinzel", serif; margin:0; min-height:100vh; background:linear-gradient(180deg,#1b0710 0%, #2a0f2f 100%); color:var(--muted); display:flex; justify-content:center; padding:24px;}
  .app{width:1100px; max-width:100%; display:grid; grid-template-columns: 1fr 360px; gap:20px; align-items:start;}
  header{grid-column:1 / -1; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1)); border:2px solid rgba(212,175,55,0.08); padding:14px; border-radius:10px; text-align:center;}
  header h1{margin:0;color:var(--accent);font-size:1.6rem}
  .panel{background:var(--panel); padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); box-shadow:0 6px 18px rgba(0,0,0,0.6);}
  .lobby{display:flex; flex-direction:column; gap:12px}
  .small{font-size:13px; color:#dcd0bf}
  .row{display:flex; gap:8px; align-items:center}
  button{background:var(--accent); color:#2b1a10; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700}
  input, select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted)}
  .hand{display:flex; gap:10px; flex-wrap:wrap}
  .card{width:110px;height:150px;border-radius:10px;background:linear-gradient(180deg,#1e1512,#291714);border:2px solid rgba(212,175,55,0.08);padding:10px;cursor:pointer;display:flex;flex-direction:column;justify-content:space-between;box-shadow:0 6px 12px rgba(0,0,0,0.6)}
  .card.back{background:linear-gradient(180deg,#291a1a,#1a0f0f); color:transparent}
  .card .name{font-weight:800;color:var(--accent)}
  .zone{min-height:180px;background:var(--glass);border-radius:8px;padding:10px;border:1px dashed rgba(255,255,255,0.03)}
  .title{font-weight:700;color:var(--accent);margin-bottom:8px}
  #log{height:240px; overflow:auto; background:rgba(0,0,0,0.45); padding:8px; border-radius:6px; font-size:13px}
  .meta{display:flex;gap:8px;justify-content:space-between;align-items:center;margin-bottom:8px}
  .center{display:flex;align-items:center;justify-content:center}
  .badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
  .hidden{display:none}
  footer{grid-column:1/-1;text-align:center;color:#bdb0a0;font-size:13px;margin-top:10px}
  .selected{outline:3px solid rgba(212,175,55,0.35); transform:translateY(-6px)}
  .flexcol{display:flex;flex-direction:column;gap:8px}
  .room-list{display:flex;flex-direction:column;gap:8px;max-height:260px;overflow:auto}
  .room-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
  .stat{font-size:13px;color:#d4ccbb}
</style>
</head>
<body>
  <div class="app">
    <header class="panel">
      <h1>ç‹ä¸å¥´ â€” å¯ç©ç½‘é¡µåŸå‹ï¼ˆå•é¡µï¼‰</h1>
      <div class="small">å›åˆåˆ¶åŒæ­¥å‡ºç‰Œ / åˆºå®¢ / å± å¤« / å®ˆå« / å¥³ç‹å³æ—¶æ›¿æ¢å›½ç‹ç­‰å®Œæ•´è§„åˆ™ã€‚æ”¯æŒå¤§å…ã€å¥½å‹ã€ä¸ªäººä¸»é¡µã€é‚€è¯·æˆ¿é—´ï¼ˆæœ¬åœ°æ¨¡æ‹Ÿï¼‰ã€‚</div>
    </header>

    <!-- Left: main area: lobby / game / profile -->
    <main id="main" class="panel lobby">
      <!-- VIEW: will be replaced by JS -->
    </main>

    <!-- Right: sidebar -->
    <aside class="panel flexcol">
      <div>
        <div class="title">ä¸ªäººä¿¡æ¯</div>
        <div id="profileBox" class="row" style="gap:12px">
          <div id="avatar" style="width:56px;height:56px;border-radius:8px;background:linear-gradient(180deg,#2a160f,#1a0b06);display:flex;align-items:center;justify-content:center;font-size:26px">ğŸ™‚</div>
          <div style="flex:1">
            <div id="displayName" style="font-weight:800"></div>
            <div class="stat" id="record">èƒœ 0 / è´Ÿ 0</div>
          </div>
        </div>
        <div style="margin-top:8px" class="small">æ˜µç§°ä¸å¤´åƒä¿å­˜åœ¨æµè§ˆå™¨ï¼Œç™»å½•åä¼šè‡ªåŠ¨æ¢å¤ã€‚</div>
        <div style="margin-top:12px" class="row">
          <button id="btnProfile">ç¼–è¾‘ä¸ªäººä¸»é¡µ</button>
          <button id="btnNewGame">åˆ›å»ºæˆ¿é—´</button>
        </div>
      </div>

      <div style="margin-top:14px">
        <div class="title">å¥½å‹ï¼ˆæœ¬åœ°ï¼‰</div>
        <div class="row" style="gap:6px;margin-bottom:6px">
          <input id="friendName" placeholder="å¥½å‹æ˜µç§°æˆ–id" style="flex:1"/>
          <button id="btnAddFriend">æ·»åŠ </button>
        </div>
        <div id="friendsList" style="display:flex;flex-direction:column;gap:6px;max-height:200px;overflow:auto"></div>
      </div>

      <div style="margin-top:14px">
        <div class="title">æˆ¿é—´ï¼ˆæœ¬åœ°ï¼‰</div>
        <div class="row" style="gap:6px">
          <input id="roomCodeInput" placeholder="è¾“å…¥æˆ¿é—´å·åŠ å…¥" style="flex:1"/>
          <button id="btnJoinRoom">åŠ å…¥</button>
        </div>
        <div style="margin-top:8px" class="small">åˆ›å»ºæˆ¿é—´åä¼šç”Ÿæˆæˆ¿é—´å·ï¼Œå¯ä¸å¥½å‹å…±äº«ï¼ˆæœ¬åœ°æ¨¡æ‹Ÿï¼‰</div>
        <div style="margin-top:8px" id="roomList" class="room-list"></div>
      </div>
    </aside>

    <footer class="panel" style="text-align:center">
      æç¤ºï¼šè¿™æ˜¯å•æœº/å±€åŸŸç½‘å¯ç©çš„å‰ç«¯åŸå‹ï¼›è‹¥éœ€åœ¨çº¿å¤šäººè¯·æ¥åç«¯ Socket æœåŠ¡ã€‚
    </footer>
  </div>

<script>
/* ===================
   Utilities & storage
   =================== */
const storeKey = 'wang_nu_profile_v1';
const friendKey = 'wang_nu_friends_v1';
const roomsKey = 'wang_nu_rooms_v1';
const recordKey = 'wang_nu_record_v1';

function saveJSON(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
function loadJSON(k, fallback){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):fallback }catch(e){return fallback}}
function uid(len=6){ return Math.random().toString(36).slice(2,2+len).toUpperCase() }

/* ===================
   Default profile
   =================== */
let profile = loadJSON(storeKey, null);
if(!profile){
  const name = prompt('æ¬¢è¿ï¼è¯·è¾“å…¥ä½ çš„æ˜µç§°ï¼ˆå°†ä¿å­˜åœ¨æœ¬åœ°ï¼‰','ç©å®¶'+Math.floor(Math.random()*999));
  profile = { id: uid(6), name: name || 'ç©å®¶', avatar: 'ğŸ™‚', wins:0, losses:0, preferred:'slave' };
  saveJSON(storeKey, profile);
}
document.getElementById('displayName').textContent = profile.name;
document.getElementById('avatar').textContent = profile.avatar;
updateRecordUI();

/* friends & rooms in localStorage */
let friends = loadJSON(friendKey, []);
let rooms = loadJSON(roomsKey, {}); // rooms: {roomId: {id, hostId, players:[ids], openingChoicePerPlayer:{}, state}}
renderFriends();
renderRoomsList();

/* ===================
   Views: lobby/profile/game
   =================== */
const main = document.getElementById('main');

function showLobby(){
  main.innerHTML = `
    <div>
      <div class="title">æ¸¸æˆå¤§å…</div>
      <div class="row" style="gap:12px;margin-top:6px">
        <label class="small">é€‰æ‹©å¼€å±€</label>
        <select id="selectOpening">
          <option value="king">å›½ç‹å¼€å±€</option>
          <option value="queen">å¥³ç‹å¼€å±€</option>
          <option value="slave">å¥´éš¶æ–¹</option>
        </select>
        <button id="btnQuickPlay">å•äººéšæœºæˆ¿ï¼ˆä¸AIï¼‰</button>
        <button id="btnCreate">åˆ›å»ºæˆ¿é—´ï¼ˆæœ¬åœ°ï¼‰</button>
      </div>

      <div style="margin-top:12px">
        <div class="title">æˆ¿é—´åˆ—è¡¨ï¼ˆæœ¬åœ°ï¼‰</div>
        <div id="lobbyRooms" class="room-list"></div>
      </div>
      <div style="margin-top:12px" class="title">è§„åˆ™é€ŸæŸ¥</div>
      <div class="small" style="line-height:1.6">
        å‡ºç‰Œï¼šåŒæ–¹åŒæ—¶é€‰æ‹©ä¸€å¼ ç‰Œç¿»å¼€åˆ¤å®šã€‚<br>
        è§„åˆ™æ‘˜è¦ï¼šåˆºå®¢ï¼ˆå¯å‡»æ€æˆ–æŠ½ç‰Œï¼‰ã€å± å¤«ï¼ˆå‡ºåœºåŒæ–¹åŒå½’äºå°½ï¼‰ã€å®ˆå«/ç»ˆæå®ˆå«ï¼ˆä¿æŠ¤/ç§’æ€åˆºå®¢ï¼‰ã€å¥³ç‹ï¼ˆä»…æœ€åä¸€å¼ å‡ºï¼Œå¯å¸¦èµ°å¯¹æ‰‹æœ¬è½®å‡ºç‰Œå¹¶è§¦å‘å›½ç‹ç«‹å³ä¸Šé˜µï¼‰ã€å¥´éš¶ï¼ˆLv0ï¼Œå¯å‡»è´¥å›½ç‹ï¼‰ç­‰ã€‚æ›´å¤šè¯¦è§æ‰‹å†Œã€‚
      </div>
    </div>
  `;
  // hook events
  document.getElementById('selectOpening').value = profile.preferred || 'slave';
  document.getElementById('selectOpening').addEventListener('change', e=>{ profile.preferred = e.target.value; saveJSON(storeKey, profile) });
  document.getElementById('btnQuickPlay').addEventListener('click', ()=> {
    const opening = document.getElementById('selectOpening').value;
    startMatchLocal({ mode:'solo', playerOpening: opening });
  });
  document.getElementById('btnCreate').addEventListener('click', ()=> createRoomLocal());
  renderLobbyRooms();
}
showLobby();

document.getElementById('btnProfile').addEventListener('click', ()=> showProfile());
document.getElementById('btnNewGame').addEventListener('click', ()=> createRoomLocal());

/* ===================
   Friends & room helper
   =================== */
document.getElementById('btnAddFriend').addEventListener('click', ()=> {
  const v = document.getElementById('friendName').value.trim();
  if(!v) return alert('è¯·è¾“å…¥æ˜µç§°æˆ–id');
  const friendId = uid(6);
  friends.push({ id:friendId, name:v, online: Math.random()<0.7 });
  saveJSON(friendKey, friends); renderFriends();
  document.getElementById('friendName').value='';
});

function renderFriends(){
  const el = document.getElementById('friendsList');
  el.innerHTML = '';
  if(friends.length===0){ el.innerHTML='<div class="small">è¿˜æ²¡æœ‰å¥½å‹ï¼ˆå¯ç”¨æœ¬åœ°æ·»åŠ ï¼‰</div>'; return }
  friends.forEach(f=>{
    const d = document.createElement('div'); d.className='row'; d.style.justifyContent='space-between';
    d.innerHTML = `<div><strong>${f.name}</strong><div class="small">ID: ${f.id} â€¢ ${f.online?'<span style="color:#7fe57f">åœ¨çº¿</span>':'ç¦»çº¿'}</div></div>
      <div style="display:flex;gap:8px"><button class="invite-btn" data-id="${f.id}">é‚€è¯·</button><button class="remove-friend" data-id="${f.id}">åˆ é™¤</button></div>`;
    el.appendChild(d);
  });
  // bind invites
  Array.from(el.querySelectorAll('.invite-btn')).forEach(btn=>{
    btn.onclick = ()=> {
      const fid = btn.dataset.id;
      const r = createRoomLocal(true);
      // simulate invite: add friend to room players for local demo
      rooms[r.id].players.push(fid);
      saveRooms(); renderRoomsList(); renderLobbyRooms();
      alert('å·²ç”Ÿæˆæˆ¿é—´å·å¹¶é‚€è¯·ï¼š' + fid + '\næˆ¿é—´å·: ' + r.id);
    }
  });
  Array.from(el.querySelectorAll('.remove-friend')).forEach(btn=>{
    btn.onclick = ()=> {
      friends = friends.filter(f=>f.id!==btn.dataset.id); saveJSON(friendKey, friends); renderFriends();
    }
  });
}

/* Rooms: local simulate */
function saveRooms(){ saveJSON(roomsKey, rooms); renderRoomsList(); renderLobbyRooms() }
function renderRoomsList(){
  const el = document.getElementById('roomList'); el.innerHTML='';
  const ks = Object.keys(rooms);
  if(ks.length===0){ el.innerHTML='<div class="small">æš‚æ— æˆ¿é—´</div>'; return }
  ks.forEach(id=>{
    const r = rooms[id];
    const div = document.createElement('div'); div.className='room-item';
    div.innerHTML = `<div><strong>${id}</strong><div class="small">ä¸»æœº: ${r.hostName} â€¢ ç©å®¶: ${r.players.length}/2</div></div>
      <div><button data-id="${id}" class="join-room">åŠ å…¥</button></div>`;
    el.appendChild(div);
  });
  Array.from(el.querySelectorAll('.join-room')).forEach(b=> b.onclick=()=> joinRoomLocal(b.dataset.id));
}
function renderLobbyRooms(){
  const el = document.getElementById('lobbyRooms'); el.innerHTML='';
  const ks = Object.keys(rooms);
  if(ks.length===0){ el.innerHTML='<div class="small">æš‚æ— æˆ¿é—´</div>'; return }
  ks.forEach(id=>{
    const r = rooms[id];
    const div = document.createElement('div'); div.className='room-item';
    div.innerHTML = `<div><strong>${id}</strong><div class="small">å¼€å±€: ${r.openingChoice} â€¢ ä¸»æœº: ${r.hostName}</div></div>
      <div><button data-id="${id}" class="join-room2">åŠ å…¥</button></div>`;
    el.appendChild(div);
  });
  Array.from(el.querySelectorAll('.join-room2')).forEach(b=> b.onclick=()=> joinRoomLocal(b.dataset.id));
}

/* Create / join room locally (simulate invite) */
function createRoomLocal(fromInvite=false){
  const id = uid(5);
  const openingChoice = profile.preferred || 'slave';
  rooms[id] = { id, hostId: profile.id, hostName: profile.name, players: [profile.id], openingChoice, state:'waiting' };
  saveRooms();
  renderLobbyRooms();
  alert('åˆ›å»ºæˆ¿é—´æˆåŠŸï¼Œæˆ¿é—´å·ï¼š' + id);
  return rooms[id];
}
document.getElementById('btnJoinRoom').addEventListener('click', ()=> {
  const code = document.getElementById('roomCodeInput').value.trim();
  if(!code) return alert('è¯·è¾“å…¥æˆ¿é—´å·'); joinRoomLocal(code);
});
function joinRoomLocal(roomId){
  const room = rooms[roomId];
  if(!room) return alert('æœªæ‰¾åˆ°è¯¥æˆ¿é—´');
  if(!room.players.includes(profile.id)) room.players.push(profile.id);
  room.state = room.players.length >= 2 ? 'ready' : 'waiting';
  saveRooms();
  openRoomUI(roomId);
}

/* ===================
   Profile view
   =================== */
function showProfile(){
  main.innerHTML = `
    <div class="title">ä¸ªäººä¸»é¡µ</div>
    <div style="display:flex;gap:12px;align-items:center">
      <div style="width:120px;height:120px;border-radius:12px;background:linear-gradient(180deg,#2a160f,#1a0b06);display:flex;align-items:center;justify-content:center;font-size:48px" id="pfAvatar">${profile.avatar}</div>
      <div style="flex:1">
        <div class="small">æ˜µç§°</div>
        <input id="pfName" value="${profile.name}" style="width:100%;margin-bottom:8px"/>
        <div class="small">é¦–é€‰å¼€å±€</div>
        <select id="pfOpening"><option value="king">å›½ç‹å¼€å±€</option><option value="queen">å¥³ç‹å¼€å±€</option><option value="slave">å¥´éš¶æ–¹</option></select>
        <div style="margin-top:8px">
          <button id="pfSave">ä¿å­˜</button>
          <button id="pfBack">è¿”å›å¤§å…</button>
        </div>
        <div style="margin-top:10px" class="small">æˆ˜ç»©ï¼š<span id="pfRecord">${profile.wins} èƒœ / ${profile.losses} è´Ÿ</span></div>
      </div>
    </div>
  `;
  document.getElementById('pfOpening').value = profile.preferred || 'slave';
  document.getElementById('pfSave').onclick = ()=>{
    profile.name = document.getElementById('pfName').value || profile.name;
    profile.preferred = document.getElementById('pfOpening').value;
    saveJSON(storeKey, profile);
    document.getElementById('displayName').textContent = profile.name;
    updateRecordUI();
    alert('å·²ä¿å­˜');
  };
  document.getElementById('pfBack').onclick = ()=> showLobby();
}

/* ===================
   Room UI & start match (local)
   =================== */
function openRoomUI(roomId){
  const room = rooms[roomId];
  if(!room) return alert('æˆ¿é—´ä¸å­˜åœ¨');
  main.innerHTML = `
    <div>
      <div class="title">æˆ¿é—´ ${roomId}</div>
      <div class="small">ä¸»æœºï¼š${room.hostName} â€¢ ç©å®¶ï¼š${room.players.length}/2</div>
      <div style="margin-top:10px" class="row">
        <label>å¼€å±€ï¼ˆä¸»æœºé¢„è®¾ï¼‰</label>
        <div class="badge">${room.openingChoice}</div>
        <button id="btnStartMatch" ${room.players.length<2? 'disabled': ''}>å¼€å§‹å¯¹æˆ˜</button>
        <button id="btnLeaveRoom">ç¦»å¼€æˆ¿é—´</button>
      </div>
      <div style="margin-top:12px"><div class="title">ç©å®¶åˆ—è¡¨</div><div id="roomPlayers"></div></div>
    </div>
  `;
  const playersDiv = document.getElementById('roomPlayers');
  playersDiv.innerHTML = room.players.map(pid=>`<div class="small">${pid===profile.id? '<strong>ï¼ˆä½ ï¼‰</strong> ' : ''}${getNameById(pid)}</div>`).join('');
  document.getElementById('btnLeaveRoom').onclick = ()=> {
    room.players = room.players.filter(x=>x!==profile.id);
    saveRooms(); showLobby();
  };
  document.getElementById('btnStartMatch').onclick = ()=> {
    // start match with opening choices
    // For local: allow both players to take room.openingChoice
    room.state='playing';
    saveRooms();
    startMatchLocal({ mode:'local', roomId, playerOpening: room.openingChoice, opponentOpening: room.openingChoice });
  }
}

/* helper */
function getNameById(id){
  if(id===profile.id) return profile.name;
  const f = friends.find(x=>x.id===id); return f?f.name:('ç©å®¶_'+id.slice(0,4));
}

/* ===================
   Game engine (local)
   - will be used by solo or room matches
   =================== */

/* Card templates same as server: */
const cardTemplates = {
  king: [
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'åˆºå®¢', tag: 'assassin', lvl:2 },
    { name: 'å± å¤«', tag: 'butcher', lvl:2 },
    { name: 'çš‡å®¶å®ˆå«', tag: 'royalguard', lvl:2 },
    { name: 'å›½ç‹', tag: 'king', lvl:3 }
  ],
  queen: [
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'åˆºå®¢', tag: 'assassin', lvl:2 },
    { name: 'å± å¤«', tag: 'butcher', lvl:2 },
    { name: 'ç»ˆæå®ˆå«', tag: 'ultguard', lvl:3 },
    { name: 'å¥³ç‹', tag: 'queen', lvl:3 }
  ],
  slave: [
    { name: 'å¥´éš¶', tag: 'slave', lvl:0 },
    { name: 'å¥´éš¶', tag: 'slave', lvl:0 },
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'å¸‚æ°‘', tag: 'citizen', lvl:1 },
    { name: 'å®ˆå«', tag: 'guard', lvl:2 },
    { name: 'åˆºå®¢', tag: 'assassin', lvl:2 },
    { name: 'å± å¤«', tag: 'butcher', lvl:2 }
  ]
};

function cloneDeck(opening){
  const src = cardTemplates[opening] || cardTemplates['slave'];
  // deep clone and random id
  return shuffleArray(src.map(c=> ({ ...JSON.parse(JSON.stringify(c)), _id: Math.random().toString(36).slice(2,9) })));
}
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; }

/* Match state */
let match = null;

/* Start a local match:
   options:
     { mode:'solo', playerOpening }
     { mode:'local', roomId, playerOpening, opponentOpening }
*/
function startMatchLocal(opts){
  const mode = opts.mode || 'solo';
  const playerOpening = opts.playerOpening || profile.preferred || 'slave';
  const opponentOpening = (opts.opponentOpening) ? opts.opponentOpening : (mode==='solo'? 'slave': playerOpening);
  // build hands
  const myHand = cloneDeck(playerOpening);
  const aiHand = cloneDeck(opponentOpening);
  match = {
    mode, roomId: opts.roomId || null,
    player: { id: profile.id, name: profile.name, hand: myHand, discard:[], played:null, opening:playerOpening },
    opponent: { id: 'AI_'+uid(4), name: (mode==='solo'?'AI æ•Œäºº':'å¯¹æ‰‹'), hand: aiHand, discard:[], played:null, opening:opponentOpening },
    round:1,
    log: [],
    state: 'select' // select -> resolve -> finished
  };
  showGameUI();
  dumpLog(`å¯¹æˆ˜å¼€å§‹ï¼šä½ (${playerOpening}) vs ${match.opponent.name} (${opponentOpening})`);
  renderGame();
}

/* Show game UI */
function showGameUI(){
  main.innerHTML = `
    <div>
      <div class="title">å¯¹æˆ˜ â€” å›åˆ <span id="roundNum">1</span></div>
      <div style="display:flex;gap:12px;margin-top:8px">
        <div style="flex:1">
          <div class="zone">
            <div class="title">å¯¹æ‰‹å‡ºç‰ŒåŒº</div>
            <div id="opponentPlayed" style="min-height:80px"></div>
            <div style="margin-top:8px" id="opponentHandWrap" class="small">å¯¹æ‰‹æ‰‹ç‰Œï¼š<span id="opponentCount"></span></div>
          </div>
          <div style="margin-top:8px" class="zone">
            <div class="title">æˆ˜æ–—/æ—¥å¿—</div>
            <div id="roundLog" style="min-height:120px"></div>
          </div>
        </div>
        <div style="width:420px">
          <div class="zone">
            <div class="title">ä½ çš„ä¿¡æ¯</div>
            <div class="small">åå­—ï¼š${profile.name}</div>
            <div class="small">å¼€å±€ï¼š<strong id="infoOpening"></strong></div>
            <div style="margin-top:8px" class="row">
              <button id="btnAutoPlay">AI æ¨¡å¼ï¼ˆè‡ªåŠ¨å‡ºç‰Œï¼‰</button>
              <button id="btnForfeit">è®¤è¾“</button>
              <button id="btnExit">è¿”å›å¤§å…</button>
            </div>
            <div style="margin-top:10px" class="small">æ‰‹ç‰Œæ•°é‡ï¼š <span id="playerCount"></span></div>
            <div style="margin-top:8px" id="log" class="small"></div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="title">ä½ çš„æ‰‹ç‰Œï¼ˆç‚¹å‡»é€‰æ‹©ï¼‰</div>
        <div id="playerHand" class="hand"></div>
        <div style="margin-top:10px" class="row">
          <button id="btnPlay">å‡ºç‰Œï¼ˆç¡®è®¤ï¼‰</button>
          <button id="btnSkip">è·³è¿‡ï¼ˆå¼ƒä¸€å¼ ï¼‰</button>
        </div>
      </div>
    </div>
  `;
  document.getElementById('btnExit').onclick = ()=> { if(confirm('è¿”å›å¤§å…å°†ä¸­æ–­å¯¹å±€ï¼Ÿ')) { match=null; showLobby(); } };
  document.getElementById('btnForfeit').onclick = ()=> { finishMatch('opponent'); };
  document.getElementById('btnAutoPlay').onclick = ()=> { // toggle auto for opponent
    match.auto = !match.auto; document.getElementById('btnAutoPlay').textContent = match.auto? 'AI æ¨¡å¼ï¼ˆå·²å¼€ï¼‰':'AI æ¨¡å¼ï¼ˆè‡ªåŠ¨å‡ºç‰Œï¼‰';
  };
  document.getElementById('btnPlay').onclick = playSelectedCard;
  document.getElementById('btnSkip').onclick = ()=> {
    if(!match) return;
    // skip: discard first card
    const c = match.player.hand.shift();
    match.player.discard.push(c);
    dumpRoundLog(`ä½ é€‰æ‹©è·³è¿‡å¹¶å¼ƒç½® ${c.name}`);
    match.round++;
    checkAfterRoundAdvance();
    renderGame();
  };
}

/* Render game state */
let selectedIndex = null;
function renderGame(){
  if(!match) return;
  document.getElementById('roundNum').textContent = match.round;
  document.getElementById('infoOpening').textContent = match.player.opening;
  document.getElementById('playerCount').textContent = match.player.hand.length;
  document.getElementById('opponentCount').textContent = match.opponent.hand.length;
  // render hand
  const handEl = document.getElementById('playerHand'); handEl.innerHTML='';
  match.player.hand.forEach((c,i)=>{
    const div = document.createElement('div'); div.className='card'; div.innerHTML = `<div class="name">${c.name}</div><div class="small">${c.tag || ''}</div><div style="text-align:right">Lv.${c.lvl}</div>`;
    div.onclick = ()=> {
      // queen can only be played if it's your last card
      if(c.tag==='queen' && match.player.hand.length>1){ alert('å¥³ç‹åªèƒ½åœ¨ä½ ä»…å‰©æœ€åä¸€å¼ ç‰Œæ—¶å‡ºåœº'); return; }
      // toggle selection
      const was = selectedIndex; selectedIndex = (selectedIndex===i? null : i);
      Array.from(handEl.children).forEach((el,idx)=> el.classList.toggle('selected', idx===selectedIndex));
    };
    if(i===selectedIndex) div.classList.add('selected');
    handEl.appendChild(div);
  });
  // opponent played area (hidden until reveal)
  const opPlayed = document.getElementById('opponentPlayed'); opPlayed.innerHTML='';
  if(match.opponent.played && match.state !== 'select'){
    const c = match.opponent.played;
    const div = document.createElement('div'); div.className='card'; div.innerHTML=`<div class="name">${c.name}</div><div class="small">${c.tag||''}</div><div style="text-align:right">Lv.${c.lvl}</div>`;
    opPlayed.appendChild(div);
  } else {
    opPlayed.innerHTML = '<div class="small">ç­‰å¾…ç¿»ç‰Œï¼ˆå›åˆç»“ç®—æ—¶æ˜¾ç¤ºï¼‰</div>';
  }
  // log
  document.getElementById('log').textContent = match.log.slice(-6).join('\\n');
  if(match.state === 'select'){
    // if auto-opponent, let opponent auto select
    if(match.auto && !match.opponent.played){
      opponentAutoPlay();
    }
  }
}

/* Opponent AI chooses a card index (simple) */
function opponentAutoPlay(){
  if(!match || match.opponent.hand.length===0) return;
  // AI avoids playing queen unless last
  let idx = match.opponent.hand.findIndex(c => c.tag !== 'queen' && c.tag !== 'ultguard');
  if(idx===-1) idx = 0;
  // if no choice, pick random
  if(idx === -1) idx = Math.floor(Math.random()*match.opponent.hand.length);
  const chosen = match.opponent.hand.splice(idx,1)[0];
  match.opponent.played = chosen;
  dumpRoundLog(`${match.opponent.name} å·²é€‰ç‰Œï¼ˆèƒŒé¢ï¼‰`);
  renderGame();
}

/* Play selected card (player) */
function playSelectedCard(){
  if(!match) return;
  if(selectedIndex==null){ alert('è¯·å…ˆé€‰æ‹©ä¸€å¼ æ‰‹ç‰Œ'); return; }
  // take card
  const card = match.player.hand.splice(selectedIndex,1)[0];
  // queen only allowed last (already enforced)
  match.player.played = card;
  dumpRoundLog(`ä½ å·²é€‰æ‹© ${card.name}`);
  // opponent choose if not yet
  if(!match.opponent.played){
    // if match.auto true: already chosen; else choose random AI
    if(match.auto){
      // nothing (auto would have chosen)
    } else {
      // simple AI: choose avoid queen unless last
      let idx = match.opponent.hand.findIndex(c => c.tag !== 'queen' && c.tag !== 'ultguard');
      if(idx===-1) idx = Math.floor(Math.random()*match.opponent.hand.length);
      const chosen = match.opponent.hand.splice(idx,1)[0];
      match.opponent.played = chosen;
      dumpRoundLog(`${match.opponent.name} å·²é€‰æ‹©ï¼ˆèƒŒé¢ï¼‰`);
    }
  }
  // set state to resolve and run resolution after small delay for UX
  match.state = 'resolve';
  renderGame();
  setTimeout(()=> { resolveRound(); }, 700);
}

/* Resolve round according to rules */
function resolveRound(){
  if(!match) return;
  const p = match.player.played || null;
  const a = match.opponent.played || null;
  dumpRoundLog(`åŒæ–¹ç¿»ç‰Œï¼š ä½  -> ${p? p.name:'æ— '}  | ${match.opponent.name} -> ${a? a.name:'æ— '}`);
  // handle empties
  if(!p && !a){ dumpRoundLog('åŒæ–¹çš†æ— ç‰Œï¼Œæœ¬å›åˆè·³è¿‡'); advanceRound(); return; }
  if(!a && p){ dumpRoundLog('å¯¹æ‰‹æ— ç‰Œï¼Œä½ è‡ªåŠ¨å›æ”¶'); match.player.hand.push(p); match.player.played=null; advanceRound(); return;}
  if(!p && a){ dumpRoundLog('ä½ æ— ç‰Œï¼Œå¯¹æ‰‹è‡ªåŠ¨å›æ”¶'); match.opponent.hand.push(a); match.opponent.played=null; advanceRound(); return;}
  // both present: apply rules in priority order
  // 1) both assassins
  if(p.tag==='assassin' && a.tag==='assassin'){
    // both randomly draw from opponent hand and die
    if(match.opponent.hand.length>0){ const r = Math.floor(Math.random()*match.opponent.hand.length); const killed = match.opponent.hand.splice(r,1)[0]; match.opponent.discard.push(killed); dumpRoundLog(`ä½ çš„åˆºå®¢æŠ½ä¸­äº†å¯¹æ‰‹çš„ ${killed.name}ï¼ˆè¢«é˜µäº¡ï¼‰`) }
    else dumpRoundLog('å¯¹æ‰‹æ— æ‰‹ç‰Œå¯æŠ½');
    if(match.player.hand.length>0){ const r = Math.floor(Math.random()*match.player.hand.length); const killed = match.player.hand.splice(r,1)[0]; match.player.discard.push(killed); dumpRoundLog(`å¯¹æ‰‹çš„åˆºå®¢æŠ½ä¸­äº†ä½ çš„ ${killed.name}ï¼ˆè¢«é˜µäº¡ï¼‰`) }
    else dumpRoundLog('ä½ æ— æ‰‹ç‰Œå¯æŠ½');
    // both played cards die
    match.player.discard.push(p); match.opponent.discard.push(a);
    match.player.played = null; match.opponent.played = null;
    advanceRound(); return;
  }
  // 2) butcher involvement (any butcher -> both die)
  if(p.tag==='butcher' || a.tag==='butcher'){
    dumpRoundLog('å± å¤«å‡ºç° â†’ åŒæ–¹å‡ºç‰Œä¸€åŒé˜µäº¡');
    match.player.discard.push(p); match.opponent.discard.push(a);
    match.player.played=null; match.opponent.played=null;
    advanceRound(); return;
  }
  // 3) assassin vs non-assassin
  if(p.tag==='assassin' && a.tag!=='assassin'){
    if(a.tag==='butcher'){ dumpRoundLog('ä½ åˆºå®¢å¯¹ä¸Šå± å¤« â†’ åŒäº¡'); match.player.discard.push(p); match.opponent.discard.push(a); match.player.played=null; match.opponent.played=null; advanceRound(); return; }
    // player choice: kill or draw
    const choice = confirm('ä½ å‡ºåˆºå®¢ï¼šæŒ‰ã€Œç¡®å®šã€=ç›´æ¥å‡»æ€å¯¹æ–¹å‡ºç‰Œï¼›æŒ‰ã€Œå–æ¶ˆã€=éšæœºæŠ½å¯¹æ–¹æ‰‹ç‰Œï¼ˆè‹¥æœ‰ï¼‰');
    if(choice){
      dumpRoundLog(`ä½ åˆºå®¢é€‰æ‹©ç›´æ¥å‡»æ€ ${a.name}`);
      match.opponent.discard.push(a); match.player.discard.push(p); match.player.played=null; match.opponent.played=null; advanceRound(); return;
    } else {
      if(match.opponent.hand.length>0){ const r = Math.floor(Math.random()*match.opponent.hand.length); const killed = match.opponent.hand.splice(r,1)[0]; match.opponent.discard.push(killed); dumpRoundLog(`ä½ åˆºå®¢éšæœºæŠ½ä¸­å¯¹æ‰‹çš„ ${killed.name}ï¼ˆè¢«é˜µäº¡ï¼‰`) } else dumpRoundLog('å¯¹æ‰‹æ— æ‰‹ç‰Œå¯æŠ½');
      match.player.discard.push(p); match.player.played=null; match.opponent.played=null; advanceRound(); return;
    }
  }
  if(a.tag==='assassin' && p.tag!=='assassin'){
    if(p.tag==='butcher'){ dumpRoundLog('å¯¹æ–¹åˆºå®¢é‡åˆ°å± å¤« â†’ åŒäº¡'); match.player.discard.push(p); match.opponent.discard.push(a); match.player.played=null; match.opponent.played=null; advanceRound(); return; }
    // opponent (AI) chooses randomly between kill/draw
    const aiChoiceKill = Math.random() < 0.6;
    if(aiChoiceKill){
      dumpRoundLog(`å¯¹æ–¹åˆºå®¢å‘åŠ¨ï¼šç›´æ¥å‡»æ€ä½ çš„ ${p.name}`);
      match.player.discard.push(p); match.opponent.discard.push(a); match.player.played=null; match.opponent.played=null; advanceRound(); return;
    } else {
      if(match.player.hand.length>0){ const r = Math.floor(Math.random()*match.player.hand.length); const killed = match.player.hand.splice(r,1)[0]; match.player.discard.push(killed); dumpRoundLog(`å¯¹æ–¹åˆºå®¢éšæœºæŠ½ä¸­ä½ çš„ ${killed.name}ï¼ˆè¢«é˜µäº¡ï¼‰`) } else dumpRoundLog('ä½ æ— æ‰‹ç‰Œå¯æŠ½');
      match.opponent.discard.push(a); match.player.played=null; match.opponent.played=null; advanceRound(); return;
    }
  }
  // 4) ultimate guard kills assassin
  if(p.tag==='ultguard' && a.tag==='assassin'){
    dumpRoundLog('ç»ˆæå®ˆå«å‡»æ€äº†å¯¹æ–¹åˆºå®¢ï¼ˆç»ˆæå®ˆå«å›æ‰‹ç‰Œï¼‰');
    match.opponent.discard.push(a);
    match.player.hand.push(p); // winner returns
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  }
  if(a.tag==='ultguard' && p.tag==='assassin'){
    dumpRoundLog('å¯¹æ–¹ç»ˆæå®ˆå«å‡»æ€äº†ä½ çš„åˆºå®¢ï¼ˆç»ˆæå®ˆå«å›æ‰‹ç‰Œï¼‰');
    match.player.discard.push(p);
    match.opponent.hand.push(a);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  }
  // 5) special: slave beats king
  if(p.tag==='slave' && a.tag==='king'){
    dumpRoundLog('ä½ ç”¨å¥´éš¶å‡»è´¥äº†å¯¹æ–¹å›½ç‹ï¼ˆä½ å›æ‰‹è¯¥å¥´éš¶ï¼Œå¯¹æ–¹å›½ç‹é˜µäº¡ï¼‰');
    match.player.hand.push(p); match.opponent.discard.push(a);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  }
  if(a.tag==='slave' && p.tag==='king'){
    dumpRoundLog('å¯¹æ–¹å¥´éš¶å‡»è´¥äº†ä½ çš„å›½ç‹ï¼ˆä½ å¤±è´¥ï¼‰');
    match.opponent.hand.push(a); match.player.discard.push(p);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  }
  // normal lv compare
  if(p.lvl > a.lvl){
    dumpRoundLog(`ä½ æ–¹èƒœå‡ºï¼š${p.name} èƒœ ${a.name}ï¼ˆèµ¢çš„ç‰Œå›æ‰‹ï¼‰`);
    match.player.hand.push(p); match.opponent.discard.push(a);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  } else if(p.lvl < a.lvl){
    dumpRoundLog(`å¯¹æ–¹èƒœå‡ºï¼š${a.name} èƒœ ${p.name}`);
    match.opponent.hand.push(a); match.player.discard.push(p);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  } else {
    dumpRoundLog(`ç­‰çº§ç›¸åŒ â†’ åŒäº¡ï¼š${p.name} & ${a.name}`);
    match.player.discard.push(p); match.opponent.discard.push(a);
    match.player.played=null; match.opponent.played=null; advanceRound(); return;
  }
}

/* After each round cleanup / queen death logic / win check */
function advanceRound(){
  // queen death handling: if queen died for someone -> instant spawn king into their hand and ultguard dies
  [match.player, match.opponent].forEach(side=>{
    const qIdx = side.discard.findIndex(c=>c.tag==='queen');
    if(qIdx!==-1){
      dumpRoundLog(`${side.name} çš„å¥³ç‹é™¨è½ -> å›½ç‹ç«‹å³ä¸Šé˜µæ›¿ä»£`);
      // remove ultguard from their hand (æ®‰èŒ)
      side.hand = side.hand.filter(x=>x.tag !== 'ultguard');
      // ensure king exists in hand
      if(!side.hand.some(x=>x.tag==='king')) side.hand.push({ name:'å›½ç‹', tag:'king', lvl:3, _id: 'spawned_'+Math.random().toString(36).slice(2,7) });
    }
  });
  // next round
  match.round++;
  // win check: if player's king in discard -> opponent wins match
  if(match.player.discard.some(c=>c.tag==='king')){ finishMatch('opponent'); return; }
  if(match.opponent.discard.some(c=>c.tag==='king')){ finishMatch('player'); return; }
  // also if one side has no cards and cannot play next round -> decide by remaining hands
  if(match.player.hand.length===0 && match.opponent.hand.length===0){ dumpRoundLog('åŒæ–¹æ‰‹ç‰Œè€—å°½ï¼Œæ¯”è¾ƒæœ€åç»“æœï¼ˆå¹³å±€å¤„ç†ä¸ºæ— ï¼‰'); finishMatch('draw'); return; }
  // reset state and render
  match.state = 'select';
  selectedIndex = null;
  renderGame();
}

/* helper: finishMatch(winner='player'|'opponent'|'draw') */
function finishMatch(winner){
  if(!match) return;
  if(winner==='player'){ dumpRoundLog('ä½ è·èƒœï¼'); profile.wins = (profile.wins||0)+1; }
  else if(winner==='opponent'){ dumpRoundLog('ä½ å¤±è´¥'); profile.losses = (profile.losses||0)+1; }
  else dumpRoundLog('å¹³å±€');
  saveJSON(storeKey, profile); updateRecordUI();
  // show summary and back to lobby
  setTimeout(()=> {
    if(confirm('å¯¹å±€ç»“æŸï¼Œè¿”å›å¤§å…ï¼Ÿ')){ match=null; showLobby(); }
  }, 600);
}

/* logs */
function dumpLog(s){ console.log(s); }
function dumpRoundLog(s){
  match.log.push('ç¬¬'+match.round+'å›åˆï¼š'+s); document.getElementById('roundLog') && (document.getElementById('roundLog').innerHTML = match.log.slice(-20).map(x=>'&gt; '+x).join('<br>'));
  // update right sidebar log
  document.getElementById('log') && (document.getElementById('log').textContent = match.log.slice(-6).join('\\n'));
}

/* update record UI in sidebar */
function updateRecordUI(){ document.getElementById('displayName').textContent = profile.name; document.getElementById('avatar').textContent = profile.avatar; document.getElementById('record').textContent = `èƒœ ${profile.wins||0} / è´Ÿ ${profile.losses||0}`; saveJSON(storeKey, profile); }

/* ===================
   Init: attach some UI flows
   =================== */
document.getElementById('btnCreate').addEventListener('click', ()=> createRoomLocal());
document.getElementById('roomCodeInput')?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') document.getElementById('btnJoinRoom').click() });
renderFriends();
renderRoomsList();
renderLobbyRooms();

</script>
</body>
</html>
